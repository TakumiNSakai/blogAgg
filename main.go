package main

import (
	"context"                  // Used to manage timeouts and cancellation across API boundaries
	"database/sql"             // Generic interface for SQL databases in Go
	_ "github.com/lib/pq"      // PostgreSQL driver (imported for its side effects)
	"log"                      // Logging functionality
	"os"                       // Access to environment and command-line args
	"rssAgg/internal/config"   // Internal config package to load user-defined config
	"rssAgg/internal/database" // Internal database access layer (e.g. generated by sqlc)
)

// state holds shared application state (config and database connection)
type state struct {
	db  *database.Queries // db lets us call SQL functions defined in the database layer
	cfg *config.Config    // cfg holds runtime configuration (e.g., current user, DB URL)
}

func main() {
	// Load configuration from file or environment
	cfg, err := config.Read()
	if err != nil {
		log.Fatalf("error reading config: %v", err) // Fatal: print error and exit
	}

	// Open a connection to the PostgreSQL database using the URL in config
	db, err := sql.Open("postgres", cfg.DBURL)
	if err != nil {
		log.Fatalf("error connecting to db: %v", err)
	}
	defer db.Close() // Ensure the DB connection is closed when the program exits

	// Wrap the database connection in the generated Queries object
	dbQueries := database.New(db)

	// Build the application's runtime state
	programState := &state{
		db:  dbQueries, // Database methods
		cfg: &cfg,      // Loaded configuration
	}

	// Create a registry of commands and their associated handler functions
	cmds := commands{
		registeredCommands: make(map[string]func(*state, command) error),
	}

	// Register all supported CLI commands and their handlers
	cmds.register("help", handlerHelp)         // Print help text
	cmds.register("register", handlerRegister) // Create a new user
	cmds.register("login", handlerLogin)       // Switch current user
	cmds.register("reset", handlerReset)       // Delete all users
	cmds.register("users", handlerListUsers)   // List all users
	cmds.register("agg", handlerAgg)           // Run periodic RSS feed scraping

	cmds.register("addfeed", middlewareLoggedIn(handlerAddFeed))           // Add and follow a new feed
	cmds.register("feeds", handlerListFeeds)                               // List all feeds
	cmds.register("follow", middlewareLoggedIn(handlerFollow))             // Follow an existing feed
	cmds.register("following", middlewareLoggedIn(handlerListFeedFollows)) // List followed feeds
	cmds.register("unfollow", middlewareLoggedIn(handlerUnfollow))         // Unfollow a feed
	cmds.register("browse", middlewareLoggedIn(handlerBrowse))             // View recent posts

	// Ensure a valid command was provided
	if len(os.Args) < 2 {
		log.Fatal("Usage: cli <command> [args...]")
		return
	}

	// Parse command name and arguments
	cmdName := os.Args[1]  // First argument is the command name
	cmdArgs := os.Args[2:] // Remaining arguments are command parameters

	// Execute the selected command with the current state
	err = cmds.run(programState, command{Name: cmdName, Args: cmdArgs})
	if err != nil {
		log.Fatal(err)
	}

}

// middlewareLoggedIn wraps a handler to ensure that a user is currently logged in.
// It looks up the user from the database using the current username in config,
// and passes the user to the original handler.
func middlewareLoggedIn(handler func(s *state, cmd command, user database.User) error) func(*state, command) error {
	return func(s *state, cmd command) error {
		user, err := s.db.GetUser(context.Background(), s.cfg.CurrentUserName)
		if err != nil {
			return err
		}

		return handler(s, cmd, user)
	}
}
